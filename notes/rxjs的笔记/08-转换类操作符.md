# 转换类操作符

> https://rxjs.dev/guide/operators 
>
> transformation Operators



## buffer

用数组收集一个流发出的值

知道另一个流发出值，

就是把当前已收集到的值发出并释放

```TS
import { fromEvent, interval } from 'rxjs';
import { buffer } from 'rxjs/operators';

const clicks = fromEvent(document, 'click');
const intervalEvents = interval(1000);
const buffered = intervalEvents.pipe(buffer(clicks));
buffered.subscribe(x => console.log(x));
```



## bufferCount

用数组收集一个流发出的值

直到达到给定的最大值(bufferSize),

如果指定了startBufferEvery，

意味着每次新一轮的收集会缓存前一次收集的startBufferEvery个值

```ts
const clicks = fromEvent(document, 'click');
const buffered = clicks.pipe(bufferCount(3));
buffered.subscribe(x => console.log(x));
```



```ts
const clicks = fromEvent(document, 'click').pipe(pluck('clientX'));
// 只要收集到3个值，就将值推送出去，并且下一轮收集会从上一轮指定索引的位置开始复用
const buffered = clicks.pipe(bufferCount(3, 1));
buffered.subscribe(x => console.log(x));
```



## bufferTime

每隔指定的时间发出收集到的值

```TS
import { fromEvent } from 'rxjs';
import { bufferTime } from 'rxjs/operators';

const clicks = fromEvent(document, 'click');
const buffered = clicks.pipe(bufferTime(1000));
buffered.subscribe(x => console.log(x));
```



## bufferToggle (没理解透这个sample)

在指定的缓冲时间段内收集所有的值，

到时间后关闭该时间段并发出所有的值

```TS
import { interval } from 'rxjs';
import { bufferToggle } from 'rxjs/operators';

const sourceInterval = interval(1000);
const startInterval = interval(5000);
const closingInterval = val => {
  console.log(`${val} 开始缓冲! 3秒后关闭`);
  return interval(3000);
};
// 每5秒会开启一个新的缓冲区以收集发出的值，3秒后发出缓冲的值，并关闭当前缓冲区
const bufferToggleInterval = sourceInterval.pipe(
  bufferToggle(
    startInterval,
    closingInterval
  )
);
const subscribe = bufferToggleInterval.subscribe(val =>
  console.log('Emitted Buffer:', val)
);
```



## bufferWhen

收集值，直到指定的Observable发出值

```ts
const oneSecondInterval = interval(1000);
const clicks = fromEvent(document, 'click');
const bufferWhenExample = oneSecondInterval.pipe(bufferWhen(() => clicks));
const subscribe = bufferWhenExample.subscribe(val =>
  console.log('Emitted Buffer: ', val)
);
```



## concatMap

将源Observable发出的每个值，

按顺序映射成一个新的Observable

```TS
const source = of(10, 100);
const example = source.pipe(concatMap(val => of(val * 2)));
const subscribe = example.subscribe(val =>
  console.log('Example w/ Promise:', val)
);
```



